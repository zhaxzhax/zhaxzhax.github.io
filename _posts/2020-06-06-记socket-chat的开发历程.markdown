---
layout: post
title:  "记socket-chat的开发历程"
date:   2020-06-06 17:10:00 +0800
tags:
  - rust
  - socket
categories:
  - Rust
  - Network
---
# 记socket-chat的开发历程

>socket-chat 一款极其简陋的socket聊天工具

### 为什么要写
计网实验，要求实现一个socket通信。我想着java语法臃肿，调api、复制代码也没有什么乐趣可言，正好自己准备用rust完成计网课设`p2p-chat`，那么先用rust实现一个socket通信练练手吧。~~于是就这么掉入坑里。~~

### 遇到了什么坑呢
一开始所有权理解不到位，采用`worker`工作线程存储`stream`发现`worker`结构体内的线程的闭包内，是调用不了`self`的，编译通不过。
后面重新做了系统设计，设计了`streamPool`来替代原来的`threadPool`，并且采用了`Arc<Mutex<T>>`的形式来共享线程间的stream。
随即我发现，stream在read阻塞时，死锁得不到释放。于是又设计了发送内容为`` ` ``的空报文来避免死锁。
同时除此以外，尽管对于`streamPool`结构体，其包含的结构体内部的`stream`数组做了死锁控制，但rust的`ownership`要求我们对最外层的`stremPool`也要做死锁控制，才能在线程间共享。这无疑让我觉得，我对于结构体的设计有误:`streamPool`作为一个较大的数据，不应该在线程间共享。最终我的解决方案是`streamPool`不在线程间共享，`streamPool`相关的两个函数，采用单线程顺序执行。这就导致了聊天室的功能薄弱，只能先等到`stream`输入完毕（即聊天室达到规定容量）后才能进行聊天。如果将加入聊天室与聊天功能作为两个线程，我们是可以做到不定长容量的。
### 那么现在的思路呢
我的想法是，我借鉴着`The book`中第20章的线程池仿作stream池，却仿的并不相像。现在想想，我应该采用`The book`中的设计，将每个stream池中的stream的`new`函数都添加一个无限循环的线程闭包。那么stream怎么输入呢？
这么一看我之前的通过stream连接时直接赋值的传递所有权的方式实在是原始，颇受其他语言思维上的影响。正是这种影响导致了我没有沿用`The book`中的设计。其实用一个`channel`通过`sender`和`receiver`来传递事件以及数据，会更加放榜，并且不用担心死锁问题。streamPool中的每个streamworker不断循环三个事件:stream输入，stream读与写，stream销毁。读与写作为工作事件，读自己的stream，写别人的stream。如果采用我之前的设计，那么读写一体，读获得的锁卡在了read函数(因为用户没有消息输入，stream没有缓冲区输入，read阻塞),导致其他streamWorker写入不了该线程的stream(即向该用户发送消息)。最终就会循环等待造成死锁，为了避免死锁，只好采用发送无意义报文的及其浪费带宽的方式解决。当然也可以采用非阻塞读，但这样又会造成很多无意义的读。
可现在，又可以换个方式了，读事件与写事件分离，读事件触发后通过`channel`发送事件与数据，唤醒其他streamWorker的写事件，读写分离后，读的阻塞就不会妨碍写了。
### 总结与反思
自己设计的实在是差。当然刚刚接触rust的所有权、生命周期思维，考虑不周其实是可以理解的。
自己主要错在哪呢，错在对`Arc<Mutex<T>>`鬼迷心窍了，总想着和别的语言一样，到处使用同一个变量。可是这可能吗？至少在rust中，这是很不方便的。
有这么一句话:
> 不要通过共享内存来通信,而应该通过通信来共享内存

正是如此。我缺乏并发编程的经验，仍然用着传统思维，希望一个stream收到消息后，能直接调用其他stream进行发送该消息。当然，业务逻辑是这样，但我们并不能据此将所有的stream设计为带上锁的共享资源，即`Arc<Mutex<T>>`，来保证其他stream都可以访问该stream。我们应该尽量减少线程间的通信，要明确哪些数据是真正需要通信的，再通过`channel`进行发送。很明显，通过共享内存无疑冗余了很多数据交流(某些stream明明不需要访问该stream的信息，却通过`Arc<Mutex<T>>`拥有该stream的访问权以及修改权)。虽然说得很乱，`channel`是优于内存共享的，能用则用，等到不能用的时候再考虑共享内存！！！

好像一个`channel`就能解决该项目的两个问题了。但我其实还有一个疑问。闭包内使用的外部数据，一定只能用move获取所有权，而不能通过引用来借用吗？(不考虑copy Trait，因为copy Trait 进入闭包的变量只有值，并不是真正的原变量)。编译器总说，闭包可能比外面的线程`outlive`导致闭包内的引用不一定有效，那么通过生命周期应该能解决吧，那么怎么给闭包定义生命周期呢？
我好像看到过这样的写法`type Job = Box<dyn FnOnce() + Send + 'static>`，嗯看来我们是可以控制闭包的类型，来控制其捕获变量的方式的。我还不是很熟练，明天应该写篇博客总结一下各种`trait`以及`smart Pointer`。

### 最后加点内容
呃呃。这里在加点关于socket的理解内容。感觉socket创建的stream像是，客户端在服务器这里创建了一个共享文件，客户端可以写，服务器可以读，服务器在客户端里创建了一个共享文件，服务器可以写，客户端可以读。共享文件抽象一下，其实就是缓冲区啦。所以客户端里stream的read以及write其实并不是在一个缓冲区读写，虽然都是通过stream调用。服务器同理。